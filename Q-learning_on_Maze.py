# -*- coding: utf-8 -*-
"""Maze_game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EdJ10DzNPJrlC1zskbnJfXJG-xRvIwba
"""

import random
class Maze:
    def __init__(self, size=4):
        self.size = size
        # 真正表示座標
        if size < 3:
            print('Size should bigger than 3')
            print('You will start at size 4')
        print(f'Start with {self.size}x{self.size} map')
        print('Please use reset() to initialize')


        self.start = None
        self.now=None
        # size 因為邊界擴大
        map_size = self.size+2
        real_size = self.size

        # 初始化牆壁
        # 建立牆壁座標
        self.walls = []
        for column in range(map_size):
            for row in range(map_size):
                if column == 0:
                    self.walls.append((column,row))
                    continue
                if column == map_size-1:
                    self.walls.append((column,row))
                    continue
                if row == 0:
                    self.walls.append((column,row))
                    continue
                if row == map_size-1:
                    self.walls.append((column,row))
                    continue
        # 初始化終點
        self.wins = []
        self.wins.append((self.size,self.size))

        # 決定陷阱
        # 初始化 traps
        self.traps = None
        trap_num = real_size-1
        trap_make = False
        # 隨機創造阻礙
        while not trap_make:
            trap_x = random.sample(range(1, real_size+1),trap_num-1)
            trap_y = random.sample(range(1, real_size+1),trap_num-1)
            traps = [i for i in zip(trap_x,trap_y)]
            # 阻礙檢驗 必須不包含頭尾 以及不可封死出入口
            # 封死入口
            if all(item in traps for item in [(1, 2), (2, 1)]):
                continue
            # 封死出口
            elif all(item in traps for item in [(real_size-1,real_size), (real_size,real_size-1)]):
                continue
            # 阻礙起點終點
            elif all(item in traps for item in [(1,1), (real_size,real_size)]):
                continue
            else:
                trap_make = True
                self.traps = traps

    # reset 定義起點與現在座標
    def reset(self):
        # 定義起點座標
        self.start = (1,1)
        self.now = self.start
        # 定義現在座標
        # 印出地圖
        self.show()
        # 回傳現在的state
        print('You reset the map')
        print('We will start at ',self.now)
        return self.now

    # 展示
    def show(self):
        for column in range(self.size+2):
            for row in range(self.size+2):
                # 參考坐標決定印出甚麼?
                # 印出主角 主角終點前 才會先印主角
                if (column, row) == self.now:
                    print('o',end="")
                    continue
                # 印出終點
                if (column, row) in self.wins:
                    print('$',end="")
                    continue
                # 印出障礙物
                if (column, row) in self.traps:
                    print('S',end="")
                    continue
                # 印出邊界
                if (column, row) in self.walls:
                    print('+',end="")
                    continue
                # 都不符合印出格子
                print(" ",end="")
            print("\n",end="")
    # 撞牆檢驗
    def check_wall(self, target):
        if tuple(target) in self.walls:
            return True
    # 死掉檢驗
    def check_dead(self, target):
        if tuple(target) in self.traps:
            # 之後回到原點reset
            return True
    # 獲勝檢驗
    def check_win(self, target):
        if tuple(target) in self.wins:
            return True
            # 回傳True

    # 移動
    def move(self, side, i):
        event=None
        win=False
        # 移動指令
        if side not in ['u','d','l','r']:
            print('You should use u, d, l, r to move!')
        else:
            # 順利移動
            # 指令
            temp = list(self.now)
            if side == 'u':
                temp[0] -= 1
            if side == 'd':
                temp[0] += 1
            if side == 'r':
                temp[1] += 1
            if side == 'l':
                temp[1] -= 1
            # 檢驗
            # 撞牆
            if self.check_wall(temp):
                print('撞牆')
                # return
                old_state = self.now
                new_state = self.now
                event='wall'
                # 不更新位置
            # 死掉
            elif self.check_dead(temp):
                print('碰到陷阱了')
                # return
                old_state = self.now
                new_state = self.now
                event='trap'
                # 不更新位置
            elif self.check_win(temp):
                # 獲勝
                print('Vicroty!')
                # 紀錄return的東西
                old_state = self.now
                # 更新下一步
                self.now = tuple(temp)
                new_state = self.now
                event='win'
                win=True
            else:
                # 紀錄return的東西
                old_state = self.now
                self.now = tuple(temp)
                new_state = self.now
                event=None
            if i != 0:
                self.show()
            return event,old_state,new_state,win

# 迷宮建立測試
maze = Maze()
state=maze.reset()
state=[i-1 for i in list(state)]
print(state)

import numpy as np
import random
# q學習法
size = 4
maze = Maze(size)

# 建立q表
q= np.ones((1,4))
s=size
q_table=np.tile(q, (s, s)).reshape((s, s, 4))
print(q_table)
maze.reset()
print(type(maze.now[1]))

maze.move('r',1)

import random
# q學習法
size = 4
maze = Maze(size)

# 建立q表
q= np.ones((1,4))
s=size
q_table=np.tile(q, (s, s)).reshape((s, s, 4))
print(q_table)
maze.reset()
print(type(maze.now[1]))

# 訓練
import time
# 主要用於清出輸出區域的內容
from IPython.display import clear_output

# 超參數
alpha=0.2
gamma=0.3
exploration=0.025*size # 處理隨機因素
epochs=500 # 訓練次數
state=maze.reset()
epchs=[]
times=[]

import tensorflow as tf
device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
    print('GPU device not found')
else:
    print('Found GPU at: {}'.format(device_name))

# 建立訓練
for epoch in range(epochs):
    print(f'進行第{epoch}回合訓練')
    # 清除輸出
    clear_output(wait=True)
    # reset同時 state會需要轉換格式
    state=maze.reset()
    state=[i-1 for i in list(state)]
    end=False
    action=0
    step=0

    while not end:
        move_index=None
        # 決定是否觸發隨機
        random = np.random.rand()
        if random < exploration:
            move_index=np.random.choice([0,1,2,3])
            move_list=['u','d','r','l']
            move=move_list[move_index]
        else:
            # 選取當前階段最大的q 轉換成index
            move_index=np.argmax(q_table[state[0],state[1]])
            # index換成移動方位
            # 上下左右 0123
            if move_index == 0:
                move='u'
            if move_index == 1:
                move='d'
            if move_index == 2:
                move='l'
            if move_index == 3:
                move='r'
        # print('move_index:',move_index,'move',move)

        # 進行移動
        # 返回移動後的: state 事件 next_state 輸贏
        action = move_index
        event, state, next_state, win = maze.move(move,0) # 0不會印出圖片
        # 轉換: state rewards next_state 輸贏
        # 獎賞機制
        if event == 'wall': # 撞牆
            rewards = -1*(size+1)
        elif event == 'trap': # 陷阱
            rewards = -10*size
        elif event == None: # 正常
            rewards = -0.25*size
        else:     # 獲勝
            rewards = size**2*3
        # 轉換state階段
        state=[i-1 for i in list(state)]
        next_state=[i-1 for i in list(next_state)]

        # print('座標',state[0],state[1],move_index)
        # print('state:',q_table[state[0],state[1],move_index])

        # 更新q value
        # old q --> 換成新的q
        old_q=q_table[state[0],state[1],move_index]
        # 新的q 換成
        new_q = (1-alpha)*old_q + alpha*(rewards+gamma*np.max(q_table[next_state[0],next_state[1]]))
        # 更新q表到當前state的動作
        q_table[state[0],state[1],action]=new_q
#         print(f'我的state{state}下一個是{next_state}動作是{action}')
#         print(q_table)
        # 紀錄次數
        step+=1
        # 判斷是否勝利結束本回合
        if win == True:
            times.append(step)
            epchs.append(epoch)
            break
        time.sleep(0)
print('訓練完成')

print(q_table)

maze.reset()

import time
state=maze.reset()
clear_output(wait=True)
time.sleep(1)
step=0
for i in range(size+20):
    state=[i-1 for i in list(state)]
    # 選擇index
    move_index=np.argmax(q_table[state[0],state[1]])
    # 轉換動作
    if move_index == 0:
        move='u'
    if move_index == 1:
        move='d'
    if move_index == 2:
        move='l'
    if move_index == 3:
        move='r'
    # 傳出動作
    event, state, next_state, win = maze.move(move, 1)
    # 更新state
    state=next_state
    time.sleep(1)
    clear_output(wait=True)
    step+=1
    # 勝利則終止
    if win ==True:
        print('You win! Total takes ',step,'steps')
        break

print(times)
print(epchs)

import matplotlib.pyplot as plt

# 將時間數據繪製成圖表
plt.plot(epchs, times, marker='o' ) # 使用'o'表示每個數據點
plt.xlabel('Epochs')
plt.ylabel('Times')
plt.title('Times vs Epochs')
plt.grid(True)  # 顯示網格線
plt.show()

